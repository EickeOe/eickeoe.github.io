{"./":{"url":"./","title":"前言","keywords":"","body":"1. 前言1. 前言 Eick的随手记 目录 dom DocumentFragment React 简单介绍 随便写点什么啦。。 "},"dom/documentfragment.html":{"url":"dom/documentfragment.html","title":"DocumentFragment","summary":"DOM的DocumentFragment对象相关笔记","keywords":"","body":"1. DocumentFragment1.1. 介绍1.2. 如何使用1. DocumentFragment DocumentFragment接口可以用来做dom级别的性能优化 1.1. 介绍 DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow) ，且不会导致性能等问题。 1.2. 如何使用 常见的使用方法是创建一个DocumentFragment 对象，在对象中组装一个DOM子树，然后使用Node对象(例如document.body)的appendChild或者insertBefore方法将该片段附加或插入到DOM中。 这种情况下被添加(append)或者被插入( inserted)的是DocumentFragment 对象的所有子节点，而非DocumentFragment 对象本身，DocumentFragment 对象变成空白DocumentFragment 对象。 这使得DocumentFragment 对象成了有用的占位符，暂时存放那些一次插入document的节点，有利于实现document的剪切、复制、粘贴操作。 因为所有的节点会被一次插入到document中，而这个操作仅发生一个重渲染的操作，而不是每个节点分别被插入到文档中(会发生多次重渲染的操作)。 const frag = document.createDocumentFragment() for (let i = 0; i 当DocumentFragment 对象插入完会自动销毁DocumentFragment 对象的内容 移除DOM到DocumentFragment对象中 如果将document中的节点添加到DocumentFragment对象中，就会从document中移除该节点，也不会从浏览器中看到该节点，添加到DocumentFragment对象的新节点也不属于DOM树 ​ 1 2 var frag=document.createDocumentFragment(); var ul = document.getElementsByTagName('ul')[0] console.log(ul) frag.appendChild(ul) 把DOM树中的ul节点添加到文档碎片中，这时dom树中的ul节点也消失了，存放在DocumentFragment对象中了，所有的操作不会重渲染dom树 "},"react/jian-dan-jie-shao.html":{"url":"react/jian-dan-jie-shao.html","title":"简单介绍","summary":"React简单介绍","keywords":"","body":"1. 简单介绍1. 简单介绍 本文档示例代码使用语言为typescript 简介 react是Facebook的一个开源JavaScript类库。核心技术和概念为jsx，组件，v-dom，data flow。 jsx react的模板代码，直接嵌入js代码中，文件后缀为.jsx或者.tsx 组件 state和props是react组件的两个核心概念 props // 示例代码 import React, { Component } from 'react'; import { render } from 'react-dom'; const Helloworld = (props) => { return {props.str}; } // 加载组件到 DOM render(, document); props是在调用组件的时候传入不同的属性，组件内部无法改变自身的props，可以把props看作组件的配置属性。 state state是组件的当前状态，可以把组件看作一个状态机，根据状态呈现不同的UI展示。一旦状态变更，组件就会自动调用render重新渲染UI，这个更改的动作会通过this.setState方法来触发。其他方式变更state是无法重新渲染的 v-dom 全称Virtual DOM，react实现的虚拟dom。组件dom结构映射在v-dom上，react在v-dom上实现了一个diff算法，当需要重新渲染组件的时候，会通过diff算法去寻找需要变更的组件，再把这个改动更新到浏览器的真实dom上。v-dom是一个纯粹的js数据结构，性能回避原生dom快很多 data flow 单向数据流是react推崇的一种应用架构方式，指只能从一个方向来修改状态，props的变更方式很好的解释了单向数据流 JSX语法 jsx全称为JavaScript XML，是ECMAScript的类似XML的语法扩展。jsx为react开发的一套语法糖，也是react的基础 // 示例代码 const helloworld = Hello world!; // 声明常量无状态组件，纯组件 const helloworldFunc = () => { // 声明无状态组件 const str = 'Hello world!'; return {str}; } interface Props{ props1:string } interface State{ state1:string } class DemoComponent extends React.Component{// class有状态组件 render(){ return Hello world! } } 组件 react在es6中的组件在写法上分为class组件和function组件，在状态上分为有状态组件和无状态组件。 写法区分 class组件 // 示例代码 interface Props{ props1:string } interface State{ state1:string } class DemoComponent extends React.Component{ render(){ return Hello world! } } class组件包含state和完整的react组件生命周期,其中渲染函数为render() function组件 // 示例代码 interface Props{ props1:string } const helloworldFunc = (props:Props) => { const str = 'Hello world!'; return {str}; } function组件中，返回值即为渲染组件，在react16.7版本之前，function组件只能作为无状态组件使用 在react16.7版本中，react引入了react hooks，function组件也可以作为有状态组件来使用了 // react hooks代码示例 import React,{useState} from 'react'; interface Props{ props1:string } const hooksDemo = (props:Props) => { const [str,setStr] = useState('hello world!'); // str即为state.str，setStr即为setState({str}),‘hello world!’为str的初始值 return {str}; } 状态区分 无状态组件 无状态组件(Stateless Component)是最基础的组件形式，由于没有状态的影响所以就是纯静态展示的作用。一般来说，各种UI库里也是最开始会开发的组件类别。如按钮、标签、输入框等。它的基本组成结构就是属性（props）加上一个渲染函数（render）。由于不涉及到状态的更新，所以这种组件的复用性也最强 有状态组件 在无状态组件的基础上，如果组件内部包含状态（state）且状态随着事件或者外部的消息而发生改变的时候，这就构成了有状态组件（Stateful Component）。有状态组件通常会带有生命周期(lifecycle)，用以在不同的时刻触发状态的更新。这种组件也是通常在写业务逻辑中最经常使用到的，根据不同的业务场景组件的状态数量以及生命周期机制也不尽相同 "}}